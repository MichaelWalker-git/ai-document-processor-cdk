# promptfooconfig.yaml - Alternative approach
description: "Testing Qwen2-VL-7B-Instruct vision model with different prompts"

# Define multiple prompt variations to test different approaches
prompts:
  # Baseline prompt - Direct and structured
  - id: "baseline_structured"
    label: "Baseline Structured Extraction"
    content: |
      You are an expert data extraction assistant. Extract ALL meaningful structured data from this medical record document.

      EXTRACTION RULES:
      1. Extract what's actually there - don't assume any specific fields will be present
      2. Identify data patterns - look for any structured information (names, dates, numbers, codes, addresses)
      3. Create appropriate field names - dynamically name fields based on the actual content found
      4. Be document-agnostic - work with any document type (forms, letters, reports, statements)
      5. Preserve original context - maintain the meaning and format of the source data


  # Step-by-step analysis prompt
  - id: "step_by_step"
    label: "Step-by-Step Analysis"
    content: |
      Analyze this medical record document step by step:

      STEP 1: DOCUMENT OVERVIEW
      - Identify document type and layout
      - Locate main sections (header, body, footer)
      - Note any forms, tables, or structured elements

      STEP 2: PATIENT INFORMATION EXTRACTION
      - Scan for patient identifiers (name variations: patient, member, client)
      - Extract patient demographics (DOB, phone)
      - Handle name formats (comma-separated, first last, etc.)

      STEP 3: FACILITY INFORMATION EXTRACTION
      - Identify healthcare facility (return address, letterhead)
      - Extract complete facility address components
      - Look for facility contact information

      STEP 4: REQUESTER INFORMATION EXTRACTION
      - Find requesting entity/individual
      - Extract requester contact details (email, fax, address)
      - Look for "release to" or "send to" sections

      STEP 5: DATE AND REFERENCE EXTRACTION
      - Find all dates and determine their purpose
      - Extract reference numbers, case IDs
      - Identify received/processed dates

      STEP 6: VALIDATION AND FORMATTING
      - Apply required formats (MM/DD/YYYY for dates, ###-###-#### for phones)
      - Validate extracted data for consistency
      - Assign confidence scores

      Return structured JSON with extracted fields and processing notes.

  # OCR-focused prompt
  - id: "ocr_focused"
    label: "OCR-Focused Extraction"
    content: |
      You are processing a medical record that may contain OCR artifacts or unclear text. Apply advanced text recognition techniques:

      OCR HANDLING STRATEGIES:
      1. Context-based correction: Use surrounding text to interpret unclear characters
      2. Pattern recognition: Identify common medical record patterns despite OCR errors
      3. Format validation: Cross-check extracted data against expected formats
      4. Confidence scoring: Rate extraction confidence based on text clarity

      SPECIFIC EXTRACTION TARGETS:
      - Patient identifiers (handle potential OCR errors in names)
      - Dates (look for MM/DD/YYYY patterns, handle digit confusion)
      - Phone numbers (recognize ###-###-#### even with OCR artifacts)
      - Addresses (piece together address components from potentially fragmented text)
      - Email addresses (look for @ symbols and domain patterns)

      QUALITY ASSURANCE:
      - Flag uncertain extractions with low confidence scores
      - Provide alternative interpretations for ambiguous text
      - Validate extracted data against logical constraints

      Extract the standard medical record fields with enhanced OCR error handling.

  # Comprehensive scanning prompt
  - id: "comprehensive_scan"
    label: "Comprehensive Document Scan"
    content: |
      Perform a comprehensive scan of this medical record document. Leave no section unexamined:

      SCANNING METHODOLOGY:
      1. TOP-TO-BOTTOM SCAN: Start from document header, process every line
      2. SECTION-BY-SECTION: Identify and process distinct document sections
      3. DETAIL-ORIENTED: Extract from headers, footers, margins, watermarks
      4. RELATIONSHIP MAPPING: Connect related information across document sections

      EXTRACTION COVERAGE:
      - Header information (letterhead, facility details)
      - Patient section (demographics, identifiers)
      - Request details (requester info, purpose)
      - Administrative data (dates, reference numbers)
      - Footer information (additional contacts, disclaimers)

      FIELD MAPPING STRATEGY:
      - Use dynamic field naming based on actual content
      - Handle multiple instances (phone1, phone2, etc.)
      - Extract table data systematically
      - Preserve original formatting and context

      VALIDATION CHECKS:
      - Cross-reference related fields for consistency
      - Validate formats against requirements
      - Check logical relationships between extracted data

      Provide complete extraction with detailed field mapping and validation results.

  # Minimal instruction prompt
  - id: "minimal_instruction"
    label: "Minimal Instruction"
    content: |
      Extract patient information, facility details, and requester information from this medical record. 
      
      Required fields:
      - Patient: First Name, Last Name, DOB (MM/DD/YYYY), Phone (###-###-####)
      - Facility: Name, Street, City, State, ZIP
      - Requester: Name, Email, Fax (###-###-####), Address
      - Dates: Date Received (MM/DD/YYYY)
      
      Return JSON format with extracted data.

  # Detailed instruction prompt
  - id: "detailed_instruction"
    label: "Detailed Instruction"
    content: |
      MEDICAL RECORD DATA EXTRACTION SPECIALIST

      MISSION: Extract comprehensive structured data from medical records with maximum accuracy and completeness.

      CORE EXTRACTION PRINCIPLES:
      1. COMPLETENESS: Extract every piece of meaningful structured data
      2. ACCURACY: Maintain original formatting and context
      3. CONSISTENCY: Apply uniform naming conventions
      4. VALIDATION: Cross-check related information
      5. ADAPTABILITY: Handle various document types and layouts

      DETAILED FIELD SPECIFICATIONS:

      PATIENT INFORMATION:
      - Patient First Name: Look for "Patient", "Member", "Client", "Print name"
      - Patient Last Name: Handle comma-separated formats (Last, First)
      - Patient DOB: Strict MM/DD/YYYY format required
      - Patient Phone: ###-###-#### format, must be near patient name section

      HEALTHCARE FACILITY:
      - Healthcare Facility: Return address, letterhead, "Release From" section
      - Facility Street: Complete street address with number and name
      - Facility City: City name in facility address block
      - Facility State: State abbreviation or full name
      - Facility ZIP: 5-digit or 9-digit ZIP code

      REQUESTER INFORMATION:
      - Requester Name: Company/individual at document top, record holder
      - Requester Email: Email address in proximity to requester name
      - Requester Fax: ###-###-#### format, look for fax indicators (>>, "fax to")
      - Requester Address: "Release To" address, typically top-middle of page

      DATE INFORMATION:
      - Date Received: MM/DD/YYYY format, processing or received date

      EXTRACTION METHODOLOGY:
      1. Systematic document scanning (top-to-bottom, left-to-right)
      2. Pattern recognition for forms and structured elements
      3. Context-aware field identification
      4. Format validation and correction
      5. Confidence scoring for each extraction

      OUTPUT REQUIREMENTS:
      - JSON format with structured field array
      - Include confidence scores and extraction notes
      - Maintain original data formatting where specified
      - Provide accuracy assessment

  # Context-aware prompt
  - id: "context_aware"
    label: "Context-Aware Extraction"
    content: |
      You are analyzing a medical record request form. Use contextual understanding to improve extraction accuracy:

      CONTEXTUAL ANALYSIS:
      1. DOCUMENT TYPE RECOGNITION: Identify if this is a release form, request letter, or administrative document
      2. LAYOUT UNDERSTANDING: Recognize standard medical form layouts and sections
      3. RELATIONSHIP MAPPING: Connect related information across different document areas
      4. SEMANTIC UNDERSTANDING: Use medical record terminology and conventions

      CONTEXT-DRIVEN EXTRACTION:
      - Patient info typically appears in dedicated sections or form fields
      - Facility info often in letterhead or "from" sections
      - Requester info in "to" or "send to" sections
      - Dates may be labeled as "received", "processed", or "date of birth"

      INTELLIGENT FIELD RECOGNITION:
      - Use proximity and labeling to identify field purposes
      - Apply medical record conventions and standards
      - Handle variations in terminology and formatting
      - Resolve ambiguous information using context clues

      EXTRACTION VALIDATION:
      - Ensure logical consistency between related fields
      - Validate data against medical record standards
      - Cross-reference information for accuracy
      - Provide confidence ratings based on context clarity

      Extract the standard medical record fields using contextual intelligence.

# Define different model configurations
providers:
  # Base configuration
  - id: ./sagemaker-provider.ts
    label: "base_config"
    config:
      endpoint: ai-dev-sagemaker-qwen-endpoint
      region: "eu-central-1"
      modelType: 'huggingface'
      temperature: 0.1
      max_tokens: 2000

# Define comprehensive test cases
tests:
  # Primary test case with multiple document types
  - name: "Horn Record - Basic Extraction"
    vars:
      key: "images/P95-Meyer req-1.jpeg"
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          const fields = data.result?.fields || [];
          const findField = (name) => fields.find(f => f.fieldName === name);
          
          // Required fields check
          const requiredFields = [
            "Patient First Name",
            "Patient Last Name", 
            "Healthcare Facility"
          ];
          
          for (const fieldName of requiredFields) {
            const field = findField(fieldName);
            if (!field || !field.value) {
              throw new Error(`Required field "${fieldName}" is missing or empty`);
            }
          }
          
          // Accuracy check
          const accuracy = parseInt(data.accuracy || "0");
          if (accuracy < 70) {
            throw new Error(`Accuracy too low: ${accuracy}% (minimum 70%)`);
          }
          
          return true;

  # Specific field validation test
  - name: "Horn Record - Field Validation"
    vars:
      key: "images/P95-Meyer req-1.jpeg"
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          const fields = data.result?.fields || [];
          const findField = (name) => fields.find(f => f.fieldName === name);

          // Specific value checks (adjust based on actual document content)
          const checks = [
            { field: "Patient First Name", expected: "John" },
            { field: "Patient Last Name", expected: "Meyer" },
            { field: "Healthcare Facility", expected: "WEST PLAINS R-VII SCHOOL DISTRICT" },
            { field: "Facility State", expected: "MO" },
            { field: "Facility City", expected: "WEST PLAINS" }
          ];

          const errors = [];
          for (const check of checks) {
            const field = findField(check.field);
            if (!field) {
              errors.push(`Field "${check.field}" not found`);
            } else if (field.value !== check.expected) {
              errors.push(`Field "${check.field}": expected "${check.expected}", got "${field.value}"`);
            }
          }

          if (errors.length > 0) {
            throw new Error(`Field validation failed: ${errors.join("; ")}`);
          }

          return true;

  # Date format validation test
  - name: "Horn Record - Date Format Validation"
    vars:
      key: "images/P95-Meyer req-1.jpeg"
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          const fields = data.result?.fields || [];
          const findField = (name) => fields.find(f => f.fieldName === name);

          // Date format validation (MM/DD/YYYY)
          const dateRegex = /^\d{2}\/\d{2}\/\d{4}$/;
          const dateFields = ["Patient DOB", "Date Received"];

          for (const fieldName of dateFields) {
            const field = findField(fieldName);
            if (field && field.value && !dateRegex.test(field.value)) {
              throw new Error(`Date field "${fieldName}" has invalid format: "${field.value}" (expected MM/DD/YYYY)`);
            }
          }

          return true;

  # Performance test
  - name: "Horn Record - Performance Test"
    vars:
      key: "images/P95-Meyer req-1.jpeg"
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);
          const accuracy = parseInt(data.accuracy || "0");

          // Performance benchmarks
          if (accuracy < 85) {
            console.warn(`Warning: Accuracy below target (${accuracy}% < 85%)`);
          }

          // Check for completeness
          const fields = data.result?.fields || [];
          const nonEmptyFields = fields.filter(f => f.value && f.value.trim() !== "");
          const completeness = (nonEmptyFields.length / fields.length) * 100;

          if (completeness < 60) {
            throw new Error(`Field completeness too low: ${completeness.toFixed(1)}% (minimum 60%)`);
          }

          return true;

  # Robustness test with edge cases
  - name: "Horn Record - Robustness Test"
    vars:
      key: "images/P95-Meyer req-1.jpeg"
    assert:
      - type: is-json
      - type: javascript
        value: |
          const data = JSON.parse(output);

          // Structure validation
          if (!data.result || !data.result.fields) {
            throw new Error("Missing required result structure");
          }

          if (!data.accuracy) {
            throw new Error("Missing accuracy score");
          }

          // Field structure validation
          const fields = data.result.fields;
          for (const field of fields) {
            if (!field.fieldName || field.value === undefined) {
              throw new Error(`Invalid field structure: ${JSON.stringify(field)}`);
            }
          }

          return true;


outputPath: ./promptfoo-results.json

